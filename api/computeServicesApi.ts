/**
 * Sparks OpenAPI
 * Generated documentation for the Logicdrop Sparks API and OpenAPI clients.  Logicdrop Sparks lets users build rules, analyze data, and automate documents.  Use it to make decisions faster, generate documents better, and learn from your data.  ### Documentation - [User Documentation](https://docs.logicdrop.com)  ### Modules - [Sparks Compute](https://docs.logicdrop.com/rules/introduction) - [Sparks Decision Tables](https://docs.logicdrop.com/rules/authoring-decision-tables) - [Sparks Documents](https://docs.logicdrop.com/documents/introduction)  ### Clients - [OpenAPI Clients](https://docs.logicdrop.com/development/sample-clients)  ### Security - [Authorizing API Requests](https://docs.logicdrop.com/development/authorization) 
 *
 * The version of the OpenAPI document: v_VERSION_._BUILD_
 * Contact: support@logicdrop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { ArtifactResponse } from '../model/artifactResponse';
import { ComputeRule } from '../model/computeRule';
import { ComputeRuleset } from '../model/computeRuleset';
import { ContainerResponse } from '../model/containerResponse';
import { DataResponse } from '../model/dataResponse';
import { DeleteArtifactRequest } from '../model/deleteArtifactRequest';
import { DeleteDataRequest } from '../model/deleteDataRequest';
import { DesignRulesRequest } from '../model/designRulesRequest';
import { DesignerResult } from '../model/designerResult';
import { GenerateRulesRequest } from '../model/generateRulesRequest';
import { ProcessorRequest } from '../model/processorRequest';
import { ProcessorResult } from '../model/processorResult';
import { RuleContainer } from '../model/ruleContainer';
import { UpdateArtifactRequest } from '../model/updateArtifactRequest';
import { UpdateRulesetResponse } from '../model/updateRulesetResponse';
import { UploadResponse } from '../model/uploadResponse';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.staging.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ComputeServicesApiApiKeys {
    api,
}

export class ComputeServicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'jwt': new HttpBasicAuth(),
        'api': new ApiKeyAuth('header', 'X-Logicdrop-ApiKey'),
        'oauth2': new OAuth(),
    }

    constructor(oAuth?: OAuth);
    constructor(oAuth: OAuth, basePath?: string) {
        if (oAuth) {
            this.oAuth = oAuth;
        }
        if (basePath) {
            this.basePath = basePath;
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ComputeServicesApiApiKeys, value: string) {
        (this.authentications as any)[ComputeServicesApiApiKeys[key]].apiKey = value;
    }
    set oAuth(oAuth: OAuth) {
        this.authentications.oauth2 = oAuth;
    }

    set tokenUrl(tokenUrl: string) {
        this.authentications.oauth2.tokenUrl = tokenUrl;
    }    
    
    set clientId(clientId: string) {
        this.authentications.oauth2.clientId = clientId;
    }   
    
    set clientSecret(clientSecret: string) {
        this.authentications.oauth2.clientSecret = clientSecret;
    }   

    /**
     * Debug rules
     * @summary Debug rules
     * @param client Client
     * @param designRulesRequest Debugging Request
     */
    public async debugRules (client: string, designRulesRequest: DesignRulesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: DesignerResult;  }> {
        const localVarPath = this.basePath + '/compute/{client}/debug'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling debugRules.');
        }

        // verify required parameter 'designRulesRequest' is not null or undefined
        if (designRulesRequest === null || designRulesRequest === undefined) {
            throw new Error('Required parameter designRulesRequest was null or undefined when calling debugRules.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(designRulesRequest, "DesignRulesRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: DesignerResult;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DesignerResult");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete rule
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param id Rule Id
     * @param v Ruleset version
     */
    public async deleteRule (client: string, project: string, artifact: string, id: string, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/rules/{id}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteRule.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteRule.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling deleteRule.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteRule.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DataResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete rules
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param deleteDataRequest Remove rules by criteria
     * @param v Ruleset version
     */
    public async deleteRules (client: string, project: string, artifact: string, deleteDataRequest: DeleteDataRequest, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/rules'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteRules.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteRules.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling deleteRules.');
        }

        // verify required parameter 'deleteDataRequest' is not null or undefined
        if (deleteDataRequest === null || deleteDataRequest === undefined) {
            throw new Error('Required parameter deleteDataRequest was null or undefined when calling deleteRules.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deleteDataRequest, "DeleteDataRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DataResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete ruleset
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     */
    public async deleteRuleset (client: string, project: string, artifact: string, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteRuleset.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteRuleset.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling deleteRuleset.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete rulesets
     * @param client Client name
     * @param project Project name
     * @param deleteArtifactRequest Remove ruleset by criteria
     */
    public async deleteRulesets (client: string, project: string, deleteArtifactRequest: DeleteArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteRulesets.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteRulesets.');
        }

        // verify required parameter 'deleteArtifactRequest' is not null or undefined
        if (deleteArtifactRequest === null || deleteArtifactRequest === undefined) {
            throw new Error('Required parameter deleteArtifactRequest was null or undefined when calling deleteRulesets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deleteArtifactRequest, "DeleteArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Process rules using a simple input/output request
     * @summary Execute ruleset
     * @param client Client
     * @param processorRequest Processor Request
     */
    public async executeRules (client: string, processorRequest: ProcessorRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ProcessorResult;  }> {
        const localVarPath = this.basePath + '/compute/{client}/execute'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling executeRules.');
        }

        // verify required parameter 'processorRequest' is not null or undefined
        if (processorRequest === null || processorRequest === undefined) {
            throw new Error('Required parameter processorRequest was null or undefined when calling executeRules.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(processorRequest, "ProcessorRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ProcessorResult;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProcessorResult");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Generate selected rules
     * @summary Generate rules
     * @param client Client
     * @param generateRulesRequest Debugging Request
     */
    public async generateRules (client: string, generateRulesRequest: GenerateRulesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/compute/{client}/debug/source'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling generateRules.');
        }

        // verify required parameter 'generateRulesRequest' is not null or undefined
        if (generateRulesRequest === null || generateRulesRequest === undefined) {
            throw new Error('Required parameter generateRulesRequest was null or undefined when calling generateRules.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(generateRulesRequest, "GenerateRulesRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Generate ruleset
     * @summary Generate ruleset
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     * @param type Compiler Type
     */
    public async generateRuleset (client: string, project: string, artifact: string, v?: string, type?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/generate'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling generateRuleset.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling generateRuleset.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling generateRuleset.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a rule
     * @summary Get rule
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param id Rule Id
     * @param v Ruleset version
     * @param view Fields to return in the results
     */
    public async getRule (client: string, project: string, artifact: string, id: string, v?: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ComputeRule;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/rules/{id}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling getRule.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getRule.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling getRule.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRule.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ComputeRule;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ComputeRule");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get an ruleset
     * @summary Get ruleset
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     * @param view Fields to return in the results
     */
    public async getRuleset (client: string, project: string, artifact: string, v?: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ComputeRuleset;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling getRuleset.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getRuleset.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling getRuleset.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ComputeRuleset;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ComputeRuleset");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get ruleset content
     * @summary Get content
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     */
    public async getRulesetContent (client: string, project: string, artifact: string, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/content'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling getRulesetContent.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getRulesetContent.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling getRulesetContent.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get ruleset request example
     * @summary Get example request
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     */
    public async getRulesetExample (client: string, project: string, artifact: string, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/example'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling getRulesetExample.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getRulesetExample.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling getRulesetExample.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get containers possibly filtered by project and/or ruleset
     * @summary List containers
     * @param client Client name
     * @param project Filter by project containers
     * @param ruleset Filter by ruleset containers
     * @param status Container status
     */
    public async listContainers (client: string, project?: string, ruleset?: string, status?: 'running' | 'stopped', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ContainerResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/containers'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling listContainers.');
        }

        if (project !== undefined) {
            localVarQueryParameters['project'] = ObjectSerializer.serialize(project, "string");
        }

        if (ruleset !== undefined) {
            localVarQueryParameters['ruleset'] = ObjectSerializer.serialize(ruleset, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'running' | 'stopped'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ContainerResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ContainerResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get rules using optional simple filters
     * @summary List rules
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     * @param criteria Criteria
     * @param type Rule types
     * @param fields Any fields that match the single value only (requires a value)
     * @param value Value to find in any fields (requires fields)
     * @param view Fields to return in the results
     * @param filter Filters to apply
     * @param order Fields to order by
     * @param tags Tags to filter by
     * @param ignoreCase Ignore case
     */
    public async listRules (client: string, project: string, artifact: string, v?: string, criteria?: string, type?: 'any' | 'guided' | 'user', fields?: Array<string>, value?: string, view?: Array<string>, filter?: Array<string>, order?: Array<string>, tags?: Array<string>, ignoreCase?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Array<ComputeRule>;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/rules'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling listRules.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listRules.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling listRules.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (criteria !== undefined) {
            localVarQueryParameters['criteria'] = ObjectSerializer.serialize(criteria, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'any' | 'guided' | 'user'");
        }

        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "Array<string>");
        }

        if (value !== undefined) {
            localVarQueryParameters['value'] = ObjectSerializer.serialize(value, "string");
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "Array<string>");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "Array<string>");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "Array<string>");
        }

        if (ignoreCase !== undefined) {
            localVarQueryParameters['ignoreCase'] = ObjectSerializer.serialize(ignoreCase, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Array<ComputeRule>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ComputeRule>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get rules using a single key/value
     * @summary List rules by key
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param key Field name
     * @param value Field value
     * @param v Ruleset version
     * @param view Fields to return in the results
     */
    public async listRulesByKey (client: string, project: string, artifact: string, key: string, value: string, v?: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Array<ComputeRule>;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/rules/{key}/{value}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)))
            .replace('{' + 'value' + '}', encodeURIComponent(String(value)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling listRulesByKey.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listRulesByKey.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling listRulesByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling listRulesByKey.');
        }

        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling listRulesByKey.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Array<ComputeRule>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ComputeRule>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get rulesets using optional simple filters
     * @summary List rulesets
     * @param client Client name
     * @param project Project name
     * @param view Fields to return in the results
     */
    public async listRulesets (client: string, project: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Array<ComputeRuleset>;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling listRulesets.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listRulesets.');
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Array<ComputeRuleset>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ComputeRuleset>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Start/Update/Stop/Remove/Rebuild containers
     * @summary Manage containers
     * @param client Client
     * @param action Action to perform
     * @param ruleContainer Container
     */
    public async manageContainer (client: string, action: 'start' | 'stop' | 'update' | 'rebuild' | 'remove' | 'restart', ruleContainer: RuleContainer, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: RuleContainer;  }> {
        const localVarPath = this.basePath + '/compute/{client}/containers'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling manageContainer.');
        }

        // verify required parameter 'action' is not null or undefined
        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling manageContainer.');
        }

        // verify required parameter 'ruleContainer' is not null or undefined
        if (ruleContainer === null || ruleContainer === undefined) {
            throw new Error('Required parameter ruleContainer was null or undefined when calling manageContainer.');
        }

        if (action !== undefined) {
            localVarQueryParameters['action'] = ObjectSerializer.serialize(action, "'start' | 'stop' | 'update' | 'rebuild' | 'remove' | 'restart'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(ruleContainer, "RuleContainer")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: RuleContainer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RuleContainer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Saves or create a rule (overwrite)
     * @summary Save rule
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param computeRule Rule to persist
     * @param v Ruleset version
     */
    public async saveRule (client: string, project: string, artifact: string, computeRule: ComputeRule, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ComputeRule;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/rules'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling saveRule.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling saveRule.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling saveRule.');
        }

        // verify required parameter 'computeRule' is not null or undefined
        if (computeRule === null || computeRule === undefined) {
            throw new Error('Required parameter computeRule was null or undefined when calling saveRule.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(computeRule, "ComputeRule")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ComputeRule;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ComputeRule");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Saves or creates an ruleset (overwrite)
     * @summary Save ruleset
     * @param client Client name
     * @param project Project name
     * @param computeRuleset Ruleset to persist
     */
    public async saveRuleset (client: string, project: string, computeRuleset: ComputeRuleset, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ComputeRuleset;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling saveRuleset.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling saveRuleset.');
        }

        // verify required parameter 'computeRuleset' is not null or undefined
        if (computeRuleset === null || computeRuleset === undefined) {
            throw new Error('Required parameter computeRuleset was null or undefined when calling saveRuleset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(computeRuleset, "ComputeRuleset")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ComputeRuleset;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ComputeRuleset");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates one ruleset
     * @summary Update ruleset
     * @param client Client name
     * @param project Project name
     * @param updateArtifactRequest ruleset to update
     */
    public async updateRuleset (client: string, project: string, updateArtifactRequest: UpdateArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateRuleset.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateRuleset.');
        }

        // verify required parameter 'updateArtifactRequest' is not null or undefined
        if (updateArtifactRequest === null || updateArtifactRequest === undefined) {
            throw new Error('Required parameter updateArtifactRequest was null or undefined when calling updateRuleset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateArtifactRequest, "UpdateArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the ruleset with custom rules using a file
     * @summary Update content using file
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     * @param file File
     */
    public async updateRulesetContentFile (client: string, project: string, artifact: string, v?: string, file?: RequestFile, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: UpdateRulesetResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/content'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateRulesetContentFile.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateRulesetContentFile.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling updateRulesetContentFile.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            const newfile: any = file;

            localVarFormParams['file'] = {
                value: newfile.buffer,
                options: {
                    filename: newfile.originalname,
                    contentType: newfile.mimetype,
                    encoding: newfile.encoding
                }
            };
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: UpdateRulesetResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateRulesetResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the ruleset with custom rules using a string
     * @summary Update content using string
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     * @param body 
     */
    public async updateRulesetContentText (client: string, project: string, artifact: string, v?: string, body?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: UpdateRulesetResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/content'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateRulesetContentText.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateRulesetContentText.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling updateRulesetContentText.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: UpdateRulesetResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateRulesetResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the ruleset with an example request
     * @summary Update example request
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     * @param body 
     */
    public async updateRulesetExample (client: string, project: string, artifact: string, v?: string, body?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: UpdateRulesetResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/example'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateRulesetExample.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateRulesetExample.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling updateRulesetExample.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: UpdateRulesetResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateRulesetResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates multiple rules
     * @summary Update rulesets
     * @param client Client name
     * @param project Project name
     * @param updateArtifactRequest Rules to update
     */
    public async updateRulesets (client: string, project: string, updateArtifactRequest: UpdateArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateRulesets.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateRulesets.');
        }

        // verify required parameter 'updateArtifactRequest' is not null or undefined
        if (updateArtifactRequest === null || updateArtifactRequest === undefined) {
            throw new Error('Required parameter updateArtifactRequest was null or undefined when calling updateRulesets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateArtifactRequest, "UpdateArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Upload a decision table (Excel workbook)
     * @summary Upload workbook
     * @param client Client name
     * @param project Project name
     * @param artifact Ruleset name
     * @param v Ruleset version
     * @param merge Merge or replace rules
     * @param file File
     */
    public async uploadWorkbook (client: string, project: string, artifact: string, v?: string, merge?: boolean, file?: RequestFile, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: UploadResponse;  }> {
        const localVarPath = this.basePath + '/compute/{client}/{project}/{artifact}/upload'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling uploadWorkbook.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling uploadWorkbook.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling uploadWorkbook.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (merge !== undefined) {
            localVarQueryParameters['merge'] = ObjectSerializer.serialize(merge, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            const newfile: any = file;

            localVarFormParams['file'] = {
                value: newfile.buffer,
                options: {
                    filename: newfile.originalname,
                    contentType: newfile.mimetype,
                    encoding: newfile.encoding
                }
            };
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: UploadResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UploadResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
