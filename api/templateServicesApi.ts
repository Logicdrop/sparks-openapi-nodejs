/**
 * Sparks OpenAPI
 * Generated documentation for the Logicdrop Sparks API and OpenAPI clients.  Logicdrop Sparks lets users build rules, analyze data, and automate documents.  Use it to make decisions faster, generate documents better, and learn from your data.  ### Documentation - [User Documentation](https://docs.logicdrop.com)  ### Modules - [Sparks Compute](https://docs.logicdrop.com/rules/introduction) - [Sparks Decision Tables](https://docs.logicdrop.com/rules/authoring-decision-tables) - [Sparks Documents](https://docs.logicdrop.com/documents/introduction)  ### Clients - [OpenAPI Clients](https://docs.logicdrop.com/development/sample-clients)  ### Security - [Authorizing API Requests](https://docs.logicdrop.com/development/authorization) 
 *
 * The version of the OpenAPI document: v_VERSION_, build# _BUILD_
 * Contact: support@logicdrop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { ArtifactResponse } from '../model/artifactResponse';
import { DeleteArtifactRequest } from '../model/deleteArtifactRequest';
import { Template } from '../model/template';
import { UpdateArtifactRequest } from '../model/updateArtifactRequest';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.staging.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum TemplateServicesApiApiKeys {
    api,
}

export class TemplateServicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'jwt': new HttpBasicAuth(),
        'api': new ApiKeyAuth('header', 'X-Logicdrop-ApiKey'),
        'oauth2': new OAuth(),
    }

    constructor(oAuth?: OAuth);
    constructor(oAuth: OAuth, basePath?: string) {
        if (oAuth) {
            this.oAuth = oAuth;
        }
        if (basePath) {
            this.basePath = basePath;
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: TemplateServicesApiApiKeys, value: string) {
        (this.authentications as any)[TemplateServicesApiApiKeys[key]].apiKey = value;
    }
    set oAuth(oAuth: OAuth) {
        this.authentications.oauth2 = oAuth;
    }

    set tokenUrl(tokenUrl: string) {
        this.authentications.oauth2.tokenUrl = tokenUrl;
    }    
    
    set clientId(clientId: string) {
        this.authentications.oauth2.clientId = clientId;
    }   
    
    set clientSecret(clientSecret: string) {
        this.authentications.oauth2.clientSecret = clientSecret;
    }   

    /**
     * 
     * @summary Delete template
     * @param client Client name
     * @param project Project name
     * @param artifact Template name
     * @param v Template version
     */
    public async deleteTemplate (client: string, project: string, artifact: string, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/templates/{client}/{project}/{artifact}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteTemplate.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteTemplate.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling deleteTemplate.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete templates
     * @param client Client name
     * @param project Project name
     * @param deleteArtifactRequest Remove templates by criteria
     */
    public async deleteTemplates (client: string, project: string, deleteArtifactRequest: DeleteArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/templates/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteTemplates.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteTemplates.');
        }

        // verify required parameter 'deleteArtifactRequest' is not null or undefined
        if (deleteArtifactRequest === null || deleteArtifactRequest === undefined) {
            throw new Error('Required parameter deleteArtifactRequest was null or undefined when calling deleteTemplates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deleteArtifactRequest, "DeleteArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get an template
     * @summary Get template
     * @param client Client name
     * @param project Project name
     * @param artifact Template name
     * @param v Template version
     * @param view Fields to return in the results
     */
    public async getTemplate (client: string, project: string, artifact: string, v?: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Template;  }> {
        const localVarPath = this.basePath + '/templates/{client}/{project}/{artifact}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling getTemplate.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getTemplate.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling getTemplate.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Template;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Template");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get templates using optional simple filters
     * @summary List templates
     * @param client Client name
     * @param project Project name
     * @param view Fields to return in the results
     */
    public async listTemplates (client: string, project: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Array<Template>;  }> {
        const localVarPath = this.basePath + '/templates/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling listTemplates.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listTemplates.');
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Array<Template>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Template>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Saves or creates a template (overwrite)
     * @summary Save template
     * @param client Client name
     * @param project Project name
     * @param template Template to persist
     */
    public async saveTemplate (client: string, project: string, template: Template, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Template;  }> {
        const localVarPath = this.basePath + '/templates/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling saveTemplate.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling saveTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling saveTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "Template")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Template;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Template");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates one template
     * @summary Update template
     * @param client Client name
     * @param project Project name
     * @param updateArtifactRequest Templates to update
     */
    public async updateTemplate (client: string, project: string, updateArtifactRequest: UpdateArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/templates/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateTemplate.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateTemplate.');
        }

        // verify required parameter 'updateArtifactRequest' is not null or undefined
        if (updateArtifactRequest === null || updateArtifactRequest === undefined) {
            throw new Error('Required parameter updateArtifactRequest was null or undefined when calling updateTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateArtifactRequest, "UpdateArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates multiple templates
     * @summary Update templates
     * @param client Client name
     * @param project Project name
     * @param updateArtifactRequest Templates to update
     */
    public async updateTemplates (client: string, project: string, updateArtifactRequest: UpdateArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/templates/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateTemplates.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateTemplates.');
        }

        // verify required parameter 'updateArtifactRequest' is not null or undefined
        if (updateArtifactRequest === null || updateArtifactRequest === undefined) {
            throw new Error('Required parameter updateArtifactRequest was null or undefined when calling updateTemplates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateArtifactRequest, "UpdateArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
