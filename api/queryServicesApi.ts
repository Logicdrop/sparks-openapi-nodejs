/**
 * Sparks OpenAPI
 * Generated documentation for the Logicdrop Sparks API and OpenAPI clients.  Logicdrop Sparks lets users build rules, analyze data, and automate documents.  Use it to make decisions faster, generate documents better, and learn from your data.  ### Documentation - [User Documentation](https://docs.logicdrop.com)  ### Modules - [Sparks Compute](https://docs.logicdrop.com/rules/introduction) - [Sparks Decision Tables](https://docs.logicdrop.com/rules/authoring-decision-tables) - [Sparks Documents](https://docs.logicdrop.com/documents/introduction)  ### Clients - [OpenAPI Clients](https://docs.logicdrop.com/development/sample-clients)  ### Security - [Authorizing API Requests](https://docs.logicdrop.com/development/authorization) 
 *
 * The version of the OpenAPI document: v_VERSION_._BUILD_
 * Contact: support@logicdrop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { ArtifactResponse } from '../model/artifactResponse';
import { DeleteArtifactRequest } from '../model/deleteArtifactRequest';
import { QueryExecuteRequest } from '../model/queryExecuteRequest';
import { UpdateArtifactRequest } from '../model/updateArtifactRequest';
import { UserQuery } from '../model/userQuery';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.staging.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum QueryServicesApiApiKeys {
    api,
}

export class QueryServicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'jwt': new HttpBasicAuth(),
        'api': new ApiKeyAuth('header', 'X-Logicdrop-ApiKey'),
        'oauth2': new OAuth(),
    }

    constructor(oAuth?: OAuth);
    constructor(oAuth: OAuth, basePath?: string) {
        if (oAuth) {
            this.oAuth = oAuth;
        }
        if (basePath) {
            this.basePath = basePath;
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: QueryServicesApiApiKeys, value: string) {
        (this.authentications as any)[QueryServicesApiApiKeys[key]].apiKey = value;
    }
    set oAuth(oAuth: OAuth) {
        this.authentications.oauth2 = oAuth;
    }

    set tokenUrl(tokenUrl: string) {
        this.authentications.oauth2.tokenUrl = tokenUrl;
    }    
    
    set clientId(clientId: string) {
        this.authentications.oauth2.clientId = clientId;
    }   
    
    set clientSecret(clientSecret: string) {
        this.authentications.oauth2.clientSecret = clientSecret;
    }   

    /**
     * 
     * @summary Delete queries
     * @param client Client name
     * @param project Project name
     * @param deleteArtifactRequest Remove queries by criteria
     */
    public async deleteQueries (client: string, project: string, deleteArtifactRequest: DeleteArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteQueries.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteQueries.');
        }

        // verify required parameter 'deleteArtifactRequest' is not null or undefined
        if (deleteArtifactRequest === null || deleteArtifactRequest === undefined) {
            throw new Error('Required parameter deleteArtifactRequest was null or undefined when calling deleteQueries.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deleteArtifactRequest, "DeleteArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete query
     * @param client Client name
     * @param project Project name
     * @param artifact Query name
     * @param v Query version
     */
    public async deleteQuery (client: string, project: string, artifact: string, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}/{artifact}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteQuery.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteQuery.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling deleteQuery.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Execute a live query
     * @summary Execute live query
     * @param client Client name
     * @param queryExecuteRequest Query to execute
     */
    public async executeQuery (client: string, queryExecuteRequest: QueryExecuteRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: object;  }> {
        const localVarPath = this.basePath + '/query/{client}/execute'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling executeQuery.');
        }

        // verify required parameter 'queryExecuteRequest' is not null or undefined
        if (queryExecuteRequest === null || queryExecuteRequest === undefined) {
            throw new Error('Required parameter queryExecuteRequest was null or undefined when calling executeQuery.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(queryExecuteRequest, "QueryExecuteRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a query
     * @summary Get query
     * @param client Client name
     * @param project Project name
     * @param artifact Query name
     * @param v Query version
     * @param view Fields to return in the results
     */
    public async getQuery (client: string, project: string, artifact: string, v?: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: UserQuery;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}/{artifact}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling getQuery.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getQuery.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling getQuery.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: UserQuery;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UserQuery");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get queries using optional simple filters
     * @summary List queries
     * @param client Client name
     * @param project Project name
     * @param view Fields to return in the results
     */
    public async listQueries (client: string, project: string, view?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Array<UserQuery>;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling listQueries.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listQueries.');
        }

        if (view !== undefined) {
            localVarQueryParameters['view'] = ObjectSerializer.serialize(view, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Array<UserQuery>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<UserQuery>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Execute a saved query
     * @summary Execute saved query
     * @param client Client name
     * @param project Project name
     * @param artifact Query name
     * @param v Query version
     */
    public async runQuery (client: string, project: string, artifact: string, v?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: object;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}/{artifact}/run'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'artifact' + '}', encodeURIComponent(String(artifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling runQuery.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling runQuery.');
        }

        // verify required parameter 'artifact' is not null or undefined
        if (artifact === null || artifact === undefined) {
            throw new Error('Required parameter artifact was null or undefined when calling runQuery.');
        }

        if (v !== undefined) {
            localVarQueryParameters['v'] = ObjectSerializer.serialize(v, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Saves or creates a query (overwrite)
     * @summary Save query
     * @param client Client name
     * @param project Project name
     * @param userQuery Query to persist
     */
    public async saveQuery (client: string, project: string, userQuery: UserQuery, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: UserQuery;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling saveQuery.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling saveQuery.');
        }

        // verify required parameter 'userQuery' is not null or undefined
        if (userQuery === null || userQuery === undefined) {
            throw new Error('Required parameter userQuery was null or undefined when calling saveQuery.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userQuery, "UserQuery")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: UserQuery;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UserQuery");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates multiple queries
     * @summary Update queries
     * @param client Client name
     * @param project Project name
     * @param updateArtifactRequest Queries to update
     */
    public async updateQueries (client: string, project: string, updateArtifactRequest: UpdateArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateQueries.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateQueries.');
        }

        // verify required parameter 'updateArtifactRequest' is not null or undefined
        if (updateArtifactRequest === null || updateArtifactRequest === undefined) {
            throw new Error('Required parameter updateArtifactRequest was null or undefined when calling updateQueries.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateArtifactRequest, "UpdateArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates one query
     * @summary Update query
     * @param client Client name
     * @param project Project name
     * @param updateArtifactRequest Query to update
     */
    public async updateQuery (client: string, project: string, updateArtifactRequest: UpdateArtifactRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }> {
        const localVarPath = this.basePath + '/query/{client}/{project}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateQuery.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling updateQuery.');
        }

        // verify required parameter 'updateArtifactRequest' is not null or undefined
        if (updateArtifactRequest === null || updateArtifactRequest === undefined) {
            throw new Error('Required parameter updateArtifactRequest was null or undefined when calling updateQuery.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateArtifactRequest, "UpdateArtifactRequest")
        };

        let authenticationPromise = Promise.resolve();

        authenticationPromise = authenticationPromise.then(async () => await this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: ArtifactResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
